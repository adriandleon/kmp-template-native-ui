
# Android Module (composeApp) Rules

## Module Overview
The `composeApp` module is the Android-specific implementation module that uses Jetpack Compose for UI and follows Android development best practices.

## Module Structure
```
composeApp/
├── src/
│   ├── androidMain/         # Android-specific implementations
│   │   ├── kotlin/          # Kotlin source code
│   │   │   └── com/yourcompany/yourapp/   # Your package structure
│   │   │       ├── feature_a/              # Feature A package
│   │   │       │   ├── FeatureAScreen.kt   # Main screen composable
│   │   │       │   ├── FeatureAViewModel.kt # ViewModel (if needed)
│   │   │       │   └── components/         # Reusable components
│   │   │       │       ├── FeatureAButton.kt
│   │   │       │       └── FeatureATextField.kt
│   │   │       ├── feature_b/              # Feature B package
│   │   │       │   ├── FeatureBScreen.kt
│   │   │       │   └── components/
│   │   │       │       └── FeatureBCustomView.kt
│   │   │       ├── common/                 # Shared components
│   │   │       │   ├── CommonButton.kt
│   │   │       │       └── CommonTextField.kt
│   │   ├── AndroidManifest.xml
│   │   ├── res/             # Android resources
│   │   └── composeResources/ # Compose-specific resources
│   └── androidUnitTest/     # Android unit tests
└── build.gradle.kts         # Module build configuration
```

> **Note**: Replace `com/yourcompany/yourapp` with your actual package structure when using this template.

### 1. Feature Package Organization
- **Screen Composables**: Main screen composables (e.g., `FeatureAScreen.kt`)
- **ViewModels**: Business logic components (e.g., `FeatureAViewModel.kt`)
- **Components**: Reusable UI components specific to the feature
- **Common**: Shared components used across multiple features

### 2. String Resource Management
- **File Location**: Place all string resources in `res/values/` directories
- **Default Language**: English strings go in `res/values/strings.xml`
- **Localized Versions**:
  - Spanish Latin America: `res/values-es-r419/strings.xml`
  - Portuguese Brazil: `res/values-pt-rBR/strings.xml`
- **Key Naming**: Use snake_case with feature prefix (e.g., `login_button_text`, `profile_name_label`)
- **String Extraction**: Never hardcode text in composables, always use `stringResource(R.string.key)`
- **Content Description**: Extract accessibility descriptions to strings (e.g., `R.string.button_login_content_description`)
- **Pluralization**: Use `Plurals` for countable items (e.g., `R.plurals.items_count`)
- **String Formatting**: Use `stringResource` with format arguments for dynamic content

## Development Guidelines

### 1. Kotlin + Android Framework
- **Language**: Use Kotlin for all Android development
- **Android SDK**: Leverage Android framework APIs appropriately
- **Kotlin Features**: Use data classes, extension functions, coroutines, etc.
- **Null Safety**: Leverage Kotlin null safety features

### 2. Jetpack Compose UI
- **UI Framework**: Use Jetpack Compose for all UI components
- **Composable Functions**: Follow Compose naming conventions (PascalCase)
- **State Management**: Use Compose state hoisting and unidirectional data flow
- **Material Design**: Follow Material Design 3 guidelines with proper theming
- Use `Modifier.testTag()` for testing
- Implement preview functions with `@Preview`
- Use `subscribeAsState()` for Decompose integration

### 3. Internationalization and Localization
- **Supported Languages**:
  - English (en) - Default language
  - Spanish Latin America (es-r419)
  - Portuguese Brazil (pt-rBR)
- **String Resources**: Extract ALL text content to `strings.xml` resource files
- **Text Content Types to Localize**:
  - UI labels and buttons
  - Error messages and notifications
  - Content descriptions for accessibility (`contentDescription`)
  - Placeholder texts
  - Tooltips and help text
  - Navigation labels
  - Form validation messages
- **Resource File Structure**:
  ```
  res/
  ├── values/strings.xml          # Default (English)
  ├── values-es-r419/strings.xml  # Spanish Latin America
  └── values-pt-rBR/strings.xml   # Portuguese Brazil
  ```
- **Naming Convention**: Use descriptive, hierarchical keys (e.g., `feature_login_button_text`, `error_network_unavailable`)
- **Accessibility**: Always provide `contentDescription` for non-text UI elements using localized strings
- **Testing**: Test UI in all supported languages to ensure proper text fitting and layout

### 4. Preview Annotations (@Preview)
- **Mandatory Requirement**: Every composable function MUST have at least one `@Preview` annotation
- **Supported Locales**: Create previews for all supported languages:
  - English (en) - Default
  - Spanish Latin America (es-r419)
  - Portuguese Brazil (pt-rBR)
- **Theme Variations**: Always include both light and dark theme previews
- **Preview Naming Convention**: Use descriptive names with locale and theme indicators:
  ```kotlin
  @Preview(name = "Login Screen - Light Theme", locale = "en")
  @Preview(name = "Login Screen - Dark Theme", locale = "en", uiMode = Configuration.UI_MODE_NIGHT_YES)
  @Preview(name = "Login Screen - Light Theme - ES", locale = "es-r419")
  @Preview(name = "Login Screen - Dark Theme - ES", locale = "es-r419", uiMode = Configuration.UI_MODE_NIGHT_YES)
  @Preview(name = "Login Screen - Light Theme - PT", locale = "pt-rBR")
  @Preview(name = "Login Screen - Dark Theme - PT", locale = "pt-rBR", uiMode = Configuration.UI_MODE_NIGHT_YES)
  ```
- **Preview Structure**: Organize previews by feature and include all variations:
  ```kotlin
  @Composable
  fun LoginScreen() {
      // Composable implementation
  }

  // Light theme previews
  @Preview(name = "Login - Light - EN", locale = "en")
  @Preview(name = "Login - Light - ES", locale = "es-r419")
  @Preview(name = "Login - Light - PT", locale = "pt-rBR")
  @Composable
  fun LoginScreenLightPreview() {
      LoginScreen()
  }

  // Dark theme previews
  @Preview(name = "Login - Dark - EN", locale = "en", uiMode = Configuration.UI_MODE_NIGHT_YES)
  @Preview(name = "Login - Dark - ES", locale = "es-r419", uiMode = Configuration.UI_MODE_NIGHT_YES)
  @Preview(name = "Login - Dark - PT", locale = "pt-rBR", uiMode = Configuration.UI_MODE_NIGHT_YES)
  @Composable
  fun LoginScreenDarkPreview() {
      LoginScreen()
  }
  ```
- **Preview Best Practices**:
  - Use `@PreviewParameter` for dynamic content when possible
  - Avoid ViewModels in previews - pass data as parameters instead
  - Test text fitting and layout in all locales
  - Verify accessibility content descriptions render correctly
  - Use meaningful preview names for easy identification
- **Preview Limitations**: Remember that previews don't have access to:
  - Network resources
  - File system
  - Full Android framework context
  - ViewModels with complex dependencies

## Code Organization and Structure

### 1. File Naming Conventions
- Use PascalCase for composable function names (e.g., `MyComposable`)
- Use descriptive names that clearly indicate the composable's purpose
- Name files after the primary composable they contain (e.g., `MyComposable.kt`)

### 3. Module Organization
- This module should only contain UI-related code (composables)
- All business logic (ViewModels, repositories) is abstracted in the `Shared` module

### 4. Component Architecture
- Design composables as small, reusable components
- Follow the single responsibility principle: each composable should have a single, well-defined purpose
- Use a hierarchical component structure to build complex UIs from smaller, simpler components
- Break down large composables into smaller, more manageable parts
- **Resource Naming**: Follow Android resource naming conventions
- **Manifest**: Properly configure AndroidManifest.xml
- **Permissions**: Request only necessary permissions
- **Lifecycle**: Handle Android lifecycle events properly
- **Memory Management**: Avoid memory leaks, use weak references when needed

### 5. Code Splitting Strategies
- Use inline functions judiciously (overuse can hurt performance)
- Consider using `derivedStateOf` to only recompose when necessary based on derived state
- Use `remember` to cache expensive calculations and avoid unnecessary recompositions

## State Management and Patterns

### 1. State Management Best Practices
- **State Hoisting**: Move state as high as possible in the composable tree to maximize reusability and testability
- **Unidirectional Data Flow**: Data flows down the composable tree, and events flow up
- **State Solutions**: Choose the right state management solution for your needs:
  - `remember` for local state
  - `mutableStateOf` or `rememberSaveable` for UI state
  - `StateFlow` or `LiveData` for reactive streams
- **Immutability**: Keep state as immutable as possible, use `copy()` to create new state objects

### 2. Common State Patterns
- Use `LaunchedEffect` or `rememberCoroutineScope` for side effects (e.g., network requests, database access)
- Use `animate*AsState` functions for smooth animations
- Use `derivedStateOf` to derive state from other state objects

### 3. Anti-patterns to Avoid
- **Reading State from Too High a Scope**: Avoid reading state too high in the composition tree
- **Mutable State without remember**: If you're not using remember, every recomposition will create new state
- **Long Composable Functions**: Break large composables into smaller, manageable parts
- **Hardcoded Values**: Avoid hardcoding values directly in composables, use resources or constants
- **Unnecessary Recomposition**: Profile your code to identify and eliminate unnecessary recompositions

## Performance Optimization

### 1. Compose Performance Techniques
- **`remember`**: Cache expensive calculations and resources
- **`derivedStateOf`**: Only recompose when derived state changes
- **`SnapshotFlow`**: Collect data from mutable state without recomposing
- **`CompositionLocalProvider`**: Use sparingly to provide implicit dependencies (can make dependencies less explicit)

### 2. Memory Management
- Implement proper memory management and lifecycle awareness
- Avoid creating large objects in composables
- Release resources when they are no longer needed
- Use `WeakReference` to avoid memory leaks
- Use proper background processing

### 3. Rendering Optimization
- Use `Modifier.drawBehind` and `Modifier.drawWithContent` for custom drawing
- Avoid overdraw by using `Modifier.clip` and `Modifier.background`
- Use `Spacer` to control layout instead of adding padding to multiple elements
- Use `LazyColumn` and `LazyRow` to display large lists of data
- Use `rememberLazyListState` to persist scroll positions

### 4. Bundle Size Optimization
- Use R8 to shrink and obfuscate your code
- Remove unused resources
- Use dynamic feature modules to deliver features on demand

### 5. Skippable Composable Functions
- Compose Compiler performs best optimization for skippable functions
- To allow skipping, a composable must meet these criteria:
  - All parameters passed to the composable are stable
  - The composable's result is the same given the same parameters

## Security Best Practices

### 1. Input Validation and Data Protection
- **Input Validation**: Sanitize user input to prevent injection attacks
- **Data Protection**: Encrypt sensitive data at rest and in transit
- **Secure API Communication**: Use HTTPS to encrypt communication between app and server
- **Authentication**: Use OAuth 2.0 or OpenID Connect for authentication
- **Authorization**: Use role-based access control (RBAC) for authorization
- **Certificate Pinning**: Implement certificate pinning to prevent man-in-the-middle attacks

## Testing Strategy

### 1. Unit Testing
- Test composables in isolation using `ComposeTestRule`
- Verify that composables render correctly and handle user input as expected
- Use `composeTestRule.setContent { ... }` to set the content of the test
- Use `composeTestRule.onNodeWithText("...").performClick()` to simulate user interactions
- Place unit tests in `androidUnitTest` directory

### 2. UI Testing
- Test the interaction between different composables and ViewModels
- Use `Koin` to inject dependencies into tests
- Organize tests by feature or screen
- Use `testTag` for element identification
- Create `*ViewRobot.kt` for UI testing
- Follow page object pattern for test organization
- Use `Mockk` to mock dependencies in unit tests
- Aim for high test coverage

## Build and Development Tools

### 1. Build Configuration
- **Gradle**: Use Kotlin DSL for build scripts
- **Dependencies**: Use version catalogs for dependency management
- **ProGuard**: Configure ProGuard rules for release builds
- **Signing**: Proper APK signing configuration

### 2. Performance Profiling
- **Layout Inspector**: Inspect composable tree and identify performance bottlenecks
- **Profiler**: Measure app performance and memory usage
- **Debugger**: Step through code and inspect variables

## Common Pitfalls and Gotchas

### 1. Frequent Mistakes
- Forgetting to use `remember` for state
- Reading state from too high a scope
- Not handling errors properly
- Not optimizing performance

### 2. Edge Cases
- Handling different screen sizes and orientations
- Handling different locales and languages
- Handling different accessibility requirements

### 3. Version Compatibility
- Be aware of breaking changes in new versions of Jetpack Compose
- Use the latest version to take advantage of new features and bug fixes
- Ensure app compatibility with different Android versions
- Use Jetpack Compose libraries compatible with your target Android version

## Error Handling
- Use `try-catch` blocks to handle exceptions in composables
- Display error messages to users in a clear and informative way
- Consider using `Snackbar` or dedicated error display composables
- Implement proper exception handling and user feedback
- Validate user input to prevent security vulnerabilities

## Code Quality and Documentation

- **Kotlin Style**: Follow Kotlin coding conventions
- **Documentation**: Use KDoc for public APIs
- **Accessibility**: Implement accessibility features
