---
description: "iOS Module (iosApp) - Swift & SwiftUI Development Rules"
globs: ["iosApp/**/*"]
alwaysApply: true
---

# iOS Module (iosApp) Rules

## Module Overview
The `iosApp` module is the iOS-specific implementation module that uses Swift and SwiftUI for UI development, following iOS development best practices and Human Interface Guidelines.

## File Structure
```
iosApp/
├── {YourAppName}/            # Main iOS app directory (rename from iosApp)
│   ├── Assets.xcassets/     # App icons and images
│   ├── ContentView.swift    # Main SwiftUI view
│   ├── {YourAppName}App.swift # App entry point (rename from iOSApp)
│   ├── Info.plist           # iOS app configuration
│   └── Preview Content/     # SwiftUI preview assets
├── Configuration/            # Build configurations
│   └── Config.xcconfig      # Xcode configuration
└── {YourAppName}.xcodeproj/ # Xcode project file (rename from iosApp.xcodeproj)
```

> **Note**: Replace `{YourAppName}` with your actual iOS app name when using this template. The default structure uses `iosApp` as the folder name, but you should rename it to match your project.

## Development Guidelines

### 1. Swift Language and General Coding
- **Language**: Use Swift for all iOS development
- **Swift Version**: Use latest stable Swift version
- **Swift Features**: Leverage Swift features like optionals, generics, protocols
- **Type Safety**: Use strong typing and avoid force unwrapping
- **Error Handling**: Use Swift error handling mechanisms
- **Code Quality**: Always prefer simple solutions and keep codebase clean and organized
- **Code Organization**: Avoid having files over 200-300 lines of code, refactor at that point
- **Duplication Prevention**: Check for existing similar code before creating new implementations
- **Change Management**: Only make changes when 95% confident about the implementation
- **Dependency Management**: Don't create extra modules or packages, keep all files in the same target and project

### 2. SwiftUI UI Framework
- **UI Framework**: Use SwiftUI for all UI components
- **App Structure**: Use `@main` and `App` protocol for the app's entry point
- **View Structure**: Organize views in a hierarchical structure
- **Navigation**: Use NavigationView and NavigationLink for navigation
- **Modifiers**: Use SwiftUI modifiers for styling and behavior
- **Lifecycle**: Use appropriate view lifecycle methods like `onAppear` and `onDisappear`
- **Scenes**: Implement `Scene`s for managing app structure
- **PreferenceKeys**: Implement custom `PreferenceKey`s for child-to-parent communication

### 3. Internationalization and Localization
- **Supported Languages**:
  - English (en) - Default language
  - Spanish Latin America (es-r419)
  - Portuguese Brazil (pt-rBR)
- **String Resources**: Extract ALL text content to `Localizable.strings` files
- **Text Content Types to Localize**:
  - UI labels and buttons
  - Error messages and notifications
  - Accessibility labels and hints (`accessibilityLabel`, `accessibilityHint`)
  - Placeholder texts
  - Tooltips and help text
  - Navigation labels
  - Form validation messages
  - Alert and action sheet texts
- **Resource File Structure**:
  ```
  iosApp/
  ├── en.lproj/Localizable.strings     # English (default)
  ├── es-r419.lproj/Localizable.strings # Spanish Latin America
  └── pt-rBR.lproj/Localizable.strings  # Portuguese Brazil
  ```
- **Naming Convention**: Use descriptive, hierarchical keys (e.g., `login.button.title`, `error.network.unavailable`)
- **Accessibility**: Always provide localized accessibility texts for non-text UI elements
- **Testing**: Test UI in all supported languages to ensure proper text fitting and layout
- **String Extraction**: Never hardcode text in SwiftUI views, always use `NSLocalizedString(key, comment: "")`
- **Accessibility Implementation**: Use `accessibilityLabel` and `accessibilityHint` with localized strings

### 4. SwiftUI Previews
- **Mandatory Requirement**: Every SwiftUI View MUST have at least one `#Preview` macro
- **Preview Structure**: Use the new `#Preview` macro syntax (iOS 17+) or `@Preview` annotation for older versions
- **Multi-Locale Previews**: Create previews for all supported languages:
  ```swift
  #Preview("Login Screen - English") {
      LoginScreen()
          .environment(\.locale, .init(identifier: "en"))
  }

  #Preview("Login Screen - Spanish") {
      LoginScreen()
          .environment(\.locale, .init(identifier: "es-r419"))
  }

  #Preview("Login Screen - Portuguese") {
      LoginScreen()
          .environment(\.locale, .init(identifier: "pt-rBR"))
  }
  ```
- **Theme Variations**: Include both light and dark mode previews:
  ```swift
  #Preview("Login Screen - Light Mode") {
      LoginScreen()
          .preferredColorScheme(.light)
  }

  #Preview("Login Screen - Dark Mode") {
      LoginScreen()
          .preferredColorScheme(.dark)
  }
  ```
- **Preview Naming Convention**: Use descriptive names with locale and theme indicators
- **Preview Organization**: Group previews by feature and include all variations
- **Preview Limitations**: Remember that previews don't have access to:
  - Network resources
  - File system
  - Full iOS framework context
  - ViewModels with complex dependencies
- **Preview Data**: Use sample data or mock objects for previews:
  ```swift
  #Preview("User Profile") {
      UserProfileView(user: User.sampleData)
  }
  ```

### 5. State Management
- **Property Wrappers**: Use appropriate property wrappers and macros
- **View Models**: Annotate view models with `@Observable`, e.g. `@Observable final class MyModel`
- Import `Shared` module for KMP code
- **State Observation**: Do not use `@State` in SwiftUI View for view model observation, use `let model: MyModel` instead
- **Data Flow**: Use `@Binding` for two-way data flow between parent and child views
- **State Sharing**:
  - For reference type state: pass the dependency to the constructor of the child view
  - For value type state with write access: use SwiftUI bindings
  - For value type state with read-only access: pass the value directly
- **Environment**: Use `@Environment` for state shared throughout the entire app or large pieces
- **Local State**: Use `@State` only for local state managed by the view itself
- **Observation Framework**: Use the Observation framework (`@Observable`, `@State`, and `@Binding`) to build reactive views

### 6. Architecture Patterns
- **ObservableObject**: Use for observable state management
- **Environment**: Use SwiftUI environment for dependency injection
- **Combine**: Use Combine framework for reactive programming
- **Protocol-Oriented**: Leverage Swift protocol-oriented programming

### 7. Data Management
- **Core Data**: Use Core Data for local data persistence
- **UserDefaults**: Use for simple key-value storage
- **Keychain**: Use Keychain for secure data storage
- **File Management**: Use FileManager for file operations
- **Networking**: Use URLSession for HTTP requests
- **Error Handling**: Implement proper error handling and propagation

### 8. iOS Conventions and Platform Integration
- **Human Interface Guidelines**: Follow Apple HIG for design
- **App Lifecycle**: Handle app lifecycle events properly
- **Memory Management**: Use ARC (Automatic Reference Counting) effectively
- **Permissions**: Request only necessary permissions
- **Background Modes**: Configure background execution appropriately
- **Shared Module**: Import and use shared business logic
- **Platform APIs**: Use iOS-specific APIs when needed
- **Native Libraries**: Use iOS frameworks and libraries
- **Third-Party SDKs**: Integrate iOS-compatible third-party libraries

### 9. Testing Strategy
- **Unit Tests**: Use Swift Testing framework for unit testing
- **UI Tests**: Use Swift Testing framework for UI testing
- **Mocking**: Use protocols and dependency injection for testing
- **Test Coverage**: Aim for high test coverage
- **Preview Testing**: Use SwiftUI previews for rapid iteration
- **Test Organization**:
  - Write unit tests for ViewModels and business logic in the UnitTests folder
  - Implement UI tests for critical user flows in the UITests folder
  - Use Preview providers for rapid UI iteration and testing

### 10. Performance Considerations
- **Lazy Loading**: Implement lazy loading for heavy content using `LazyVStack`, `LazyHStack`, or `LazyVGrid`
- **Image Optimization**: Use appropriate image formats and sizes
- **Memory Profiling**: Use Instruments for performance analysis
- **Background Processing**: Use background tasks appropriately
- **Battery Optimization**: Minimize battery impact
- **ForEach Optimization**: Optimize ForEach loops by using stable identifiers

### 11. Build and Configuration
- **Xcode**: Use Xcode for iOS development
- **Configuration**: Use xcconfig files for build settings
- **Signing**: Configure proper code signing
- **Provisioning**: Set up provisioning profiles
- **Deployment**: Configure deployment targets

### 12. Dependency Management
- **Swift Package Manager**: Use Swift Package Manager (SPM) as the primary dependency management tool
- **Package Sources**: Add dependencies through Xcode's Package Dependencies interface
- **Version Management**: Use semantic versioning constraints for dependency versions
- **Local Packages**: Prefer remote packages over local package references
- **Dependency Resolution**: Let SPM automatically resolve dependency conflicts
- **Package.swift**: Avoid manual Package.swift editing, use Xcode's built-in SPM interface
- **Third-Party Libraries**: Integrate iOS-compatible third-party libraries through SPM
- **Alternative Tools**: Only use CocoaPods or Carthage if SPM is not supported by the library. But avoid using CocoaPods or Carthage.

### 13. Code Quality and Security
- **Swift Style**: Follow Swift style guidelines
- **Documentation**: Use Swift documentation comments
- **Error Handling**: Implement proper error handling and user feedback
- **Accessibility**: Implement accessibility features
- **Localization**: Support multiple languages and regions
- **App Transport Security**: Configure ATS appropriately
- **Data Encryption**: Encrypt sensitive data
- **Certificate Pinning**: Implement certificate pinning if needed
- **Privacy**: Follow privacy guidelines and requirements
- **Security Best Practices**:
  - Don't expose sensitive information in network requests
  - Don't store sensitive information insecurely on device
  - Follow best practices for building secure apps

### 14. App Store Guidelines
- **Review Guidelines**: Follow App Store review guidelines
- **Metadata**: Provide proper app metadata
- **Screenshots**: Create compelling app screenshots
- **Keywords**: Optimize app store keywords
- **Ratings**: Maintain appropriate content ratings
