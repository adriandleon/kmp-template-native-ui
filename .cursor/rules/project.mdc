
# Kotlin Multiplatform Project Rules - Template

## Project Overview
This is a Kotlin Multiplatform (KMP) project template that targets iOS and Android platforms. The project follows a modular architecture with clear separation of concerns and can be easily adapted for any new KMP project.

## Project Structure
```
{ProjectName}/
├── shared/           # Core KMP module (pure Kotlin)
├── composeApp/       # Android app module (Kotlin + Jetpack Compose)
├── iosApp/          # iOS app module (Swift + SwiftUI)
├── build.gradle.kts  # Root project configuration
└── gradle/          # Gradle wrapper and version catalogs
```

## Module Responsibilities

### shared Module
- **Purpose**: Core business logic, data models, and platform-agnostic code
- **Language**: Pure Kotlin (no platform-specific code)
- **Targets**: Android, iOS, JVM
- **Contains**:
  - Common business logic
  - Data models and interfaces
  - Platform abstractions
  - Shared utilities and extensions

### composeApp Module
- **Purpose**: Android-specific implementation and UI
- **Language**: Kotlin + Android framework
- **UI Framework**: Jetpack Compose
- **Contains**:
  - Android-specific implementations
  - Compose UI components
  - Android manifest and resources
  - Platform-specific adapters

### iosApp Module
- **Purpose**: iOS-specific implementation and UI
- **Language**: Swift + iOS framework
- **UI Framework**: SwiftUI
- **Contains**:
  - iOS-specific implementations
  - SwiftUI views and components
  - iOS app configuration
  - Platform-specific adapters

## Development Guidelines

### Code Organization
1. **Shared Code**: All common business logic should be in the `shared` module
2. **Platform-Specific Code**: Platform-specific implementations should be in respective modules
3. **Dependencies**: Use `expect/actual` declarations for platform-specific implementations
4. **Imports**: Always import from the `shared` module when possible

### Kotlin Conventions
- Follow Kotlin coding conventions and style guide
- Use Kotlin-specific features (data classes, extension functions, etc.)
- Prefer immutable data structures
- Use coroutines for asynchronous operations
- Follow KMP best practices for platform abstraction

### Android (composeApp) Conventions
- Use Jetpack Compose for UI components
- Follow Material Design guidelines
- Use Android architecture components (ViewModel, LiveData, etc.)
- Follow Android development best practices
- Use Kotlin DSL for build scripts

### iOS (iosApp) Conventions
- Use SwiftUI for UI components
- Follow iOS Human Interface Guidelines
- Use Swift concurrency (async/await)
- Follow iOS development best practices
- Maintain proper memory management

## Build System
- **Root**: Uses Gradle with Kotlin DSL (`build.gradle.kts`)
- **Version Management**: Uses Gradle version catalogs (`gradle/libs.versions.toml`)
- **Multiplatform**: Configured for Android, iOS, and JVM targets
- **Dependencies**: Managed through version catalogs for consistency

## Testing Strategy
- **Shared Tests**: Unit tests in `shared/commonTest`
- **Android Tests**: Unit tests in `composeApp/androidUnitTest`
- **iOS Tests**: Unit tests in `iosApp` (Swift testing framework)

## Platform Abstraction
1. **Common Interfaces**: Define in `shared` module
2. **Platform Implementations**: Implement in respective platform modules
3. **Expect/Actual**: Use for platform-specific code that shares the same interface
4. **Dependency Injection**: Consider using Koin or similar for platform-agnostic DI

## File Naming Conventions
- **Kotlin Files**: Use PascalCase (e.g., `Platform.kt`, `Greeting.kt`)
- **Swift Files**: Use PascalCase (e.g., `ContentView.swift`, `iOSApp.swift`)
- **Resource Files**: Follow platform conventions
- **Test Files**: Suffix with `Test` (e.g., `SharedCommonTest.kt`)

## Import Guidelines
- **Shared Code**: Import from your project's package structure (e.g., `com.yourcompany.yourapp.*`)
- **Platform Code**: Import platform-specific frameworks as needed
- **Avoid**: Circular dependencies between modules
- **Prefer**: Explicit imports over wildcard imports

## Error Handling
- Use Kotlin Result type for error handling in shared code
- Platform-specific error handling in respective modules
- Consistent error reporting across platforms

## Performance Considerations
- Minimize platform-specific code in shared module
- Use lazy initialization where appropriate
- Consider memory usage patterns for both platforms
- Profile and optimize platform-specific implementations

## Documentation
- Document all public APIs in shared module
- Use KDoc for Kotlin code
- Use Swift documentation comments for iOS code
- Maintain README with setup and build instructions
- Document the integration of every third party SDK or API in the `/docs` folder. Use markdown files for documentation.
- Include an index content with proper navigation in each `.md` file for documentation.
- Include links to each documentation in the root's `README.md` file.
- Document in easy human-readable language, avoiding technical jargon where possible.
- Include step-by-step to replicate any configuration for local development.

## Common Patterns
1. **Repository Pattern**: Use for data access abstraction
2. **Use Case Pattern**: For business logic in shared module
3. **MVVM**: For UI architecture in both platforms
4. **Dependency Injection**: For managing dependencies across modules

## Build and Deployment
- **Android**: Build APK/AAB through Gradle
- **iOS**: Build through Xcode
- **Shared**: Compile for all target platforms
- **Versioning**: Maintain consistent versioning across modules

## Troubleshooting
- Check Gradle sync for build issues
- Verify platform-specific implementations match shared interfaces
- Ensure proper dependency declarations in build files
- Check for platform-specific code accidentally placed in shared module

## Customization for New Projects

### 1. Update Package Names
- Replace `com.adriandeleon.template` with your package name
- Update in `composeApp/build.gradle.kts`
- Update in `shared/build.gradle.kts`
- Update in `iosApp/YourApp/Info.plist`

### 2. Update Project Names
- Replace `Template` with your project name
- Update iOS app folder name
- Update Xcode project name
- Update Android app name

### 3. Update Module Paths
- Ensure `shared/`, `composeApp/`, and `iosApp/` paths match your structure
- Update any hardcoded paths in build files
- Verify iOS app folder structure matches your naming

### 4. Update Documentation
- Update README.md with your project details
- Update documentation file references
- Update GitHub Actions workflow variables
- Update Dangerfile configuration

- Check Gradle sync for build issues
- Verify platform-specific implementations match shared interfaces
- Ensure proper dependency declarations in build files
- Check for platform-specific code accidentally placed in shared module
